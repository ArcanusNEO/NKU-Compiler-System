% -*- coding: utf-8 -*-
%-------------------------designed by zcf--------------
\documentclass[UTF8,a4paper,10pt]{ctexart}
\usepackage[left=3.17cm, right=3.17cm, top=2.74cm, bottom=2.74cm]{geometry}
\usepackage{amsmath}
\usepackage{graphicx,subfig}
\usepackage{float}
\usepackage{cite}
\usepackage{caption}
\usepackage{enumerate}
\usepackage{booktabs} %表格
\usepackage{multirow}
\usepackage{minted}
\usemintedstyle{xcode}
\usepackage{svg}
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}  %表格强制换行
%-------------------------字体设置--------------
% \usepackage{times} 
\usepackage{ctex}
\setCJKmainfont[ItalicFont=Noto Sans CJK SC Bold, BoldFont=Noto Serif CJK SC Black]{Noto Serif CJK SC}
\newcommand{\yihao}{\fontsize{26pt}{36pt}\selectfont}           % 一号, 1.4 倍行距
\newcommand{\erhao}{\fontsize{22pt}{28pt}\selectfont}          % 二号, 1.25倍行距
\newcommand{\xiaoer}{\fontsize{18pt}{18pt}\selectfont}          % 小二, 单倍行距
\newcommand{\sanhao}{\fontsize{16pt}{24pt}\selectfont}  %三号字
\newcommand{\xiaosan}{\fontsize{15pt}{22pt}\selectfont}        % 小三, 1.5倍行距
\newcommand{\sihao}{\fontsize{14pt}{21pt}\selectfont}            % 四号, 1.5 倍行距
\newcommand{\banxiaosi}{\fontsize{13pt}{19.5pt}\selectfont}    % 半小四, 1.5倍行距
\newcommand{\xiaosi}{\fontsize{12pt}{18pt}\selectfont}            % 小四, 1.5倍行距
\newcommand{\dawuhao}{\fontsize{11pt}{11pt}\selectfont}       % 大五号, 单倍行距
\newcommand{\wuhao}{\fontsize{10.5pt}{15.75pt}\selectfont}    % 五号, 单倍行距
%-------------------------章节名----------------
\usepackage{ctexcap} 
\CTEXsetup[name={,、},number={ \chinese{section}}]{section}
\CTEXsetup[name={（,）},number={\chinese{subsection}}]{subsection}
\CTEXsetup[name={,.},number={\arabic{subsubsection}}]{subsubsection}
%-------------------------页眉页脚--------------
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\kaishu \leftmark}
% \chead{}
\rhead{\kaishu 预备工作1}%加粗\bfseries 
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\renewcommand{\headrulewidth}{0.1pt}  
\renewcommand{\footrulewidth}{0pt}%去掉横线
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}%标题横线
\newcommand{\HRulegrossa}{\rule{\linewidth}{1.2mm}}
%-----------------------伪代码------------------
\usepackage{algorithm}  
\usepackage{algorithmicx}  
\usepackage{algpseudocode}  
\floatname{algorithm}{Algorithm}  
\renewcommand{\algorithmicrequire}{\textbf{Input:}}  
\renewcommand{\algorithmicensure}{\textbf{Output:}} 
\usepackage{lipsum}  
\makeatletter
\newenvironment{breakablealgorithm}
  {% \begin{breakablealgorithm}
  \begin{center}
     \refstepcounter{algorithm}% New algorithm
     \hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
     \renewcommand{\caption}[2][\relax]{% Make a new \caption
      {\raggedright\textbf{\ALG@name~\thealgorithm} ##2\par}%
      \ifx\relax##1\relax % #1 is \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
      \else % #1 is not \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
      \fi
      \kern2pt\hrule\kern2pt
     }
  }{% \end{breakablealgorithm}
     \kern2pt\hrule\relax% \@fs@post for \@fs@ruled
  \end{center}
  }
\makeatother
%------------------------代码-------------------
\usepackage{xcolor} 
\usepackage{listings} 
\lstset{ 
breaklines,%自动换行
basicstyle=\small,
escapeinside=``,
keywordstyle=\color{ blue!70} \bfseries,
commentstyle=\color{red!50!green!50!blue!50},% 
stringstyle=\ttfamily,% 
extendedchars=false,% 
linewidth=\textwidth,% 
numbers=left,% 
numberstyle=\tiny \color{blue!50},% 
frame=trbl% 
rulesepcolor= \color{ red!20!green!20!blue!20} 
}
%------------超链接----------
\usepackage[colorlinks,linkcolor=black,anchorcolor=blue]{hyperref}
%------------------------TODO-------------------
\usepackage{enumitem,amssymb}
\newlist{todolist}{itemize}{2}
\setlist[todolist]{label=$\square$}
% for check symbol 
\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%
\newcommand{\done}{\rlap{$\square$}{\raisebox{2pt}{\large\hspace{1pt}\cmark}}\hspace{-2.5pt}}
\newcommand{\wontfix}{\rlap{$\square$}{\large\hspace{1pt}\xmark}}
%------------------------水印-------------------
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{eso-pic}

\newcommand{\watermark}[3]{\AddToShipoutPictureBG{
\parbox[b][\paperheight]{\paperwidth}{
\vfill%
\centering%
\tikz[remember picture, overlay]%
  \node [rotate = #1, scale = #2] at (current page.center)%
    {\textcolor{gray!80!cyan!30!magenta!30}{#3}};
\vfill}}}

%———————————————————————————————————————————正文———————————————————————————————————————————————
%----------------------------------------------
\begin{document}
\begin{titlepage}
  \begin{center}
    \includegraphics[width=0.8\textwidth]{figure/NKU.png}\\[1cm]
    \textsc{\Huge \kaishu{\textbf{南\ \ \ \ \ \ 开\ \ \ \ \ \ 大\ \ \ \ \ \ 学}} }\\[0.9cm]
    \textsc{\huge \kaishu{\textbf{计\ \ 算\ \ 机\ \ 学\ \ 院}}}\\[0.5cm]
    % \textsc{\Large \textbf{预习报告}}\\[0.8cm]
    \HRule \\[0.9cm]
    { \LARGE \bfseries 预备工作1}\\[0.4cm]
    \HRule \\[2.0cm]
    \centering
    \textsc{\LARGE 丁屹\kaishu{\ \ \ \ }}\\[0.5cm]
    \textsc{\LARGE \kaishu{年级\ :\ 2020级}}\\[0.5cm]
    \textsc{\LARGE \kaishu{专业\ :\ 计算机科学与技术}}\\[0.5cm]
    % \textsc{\LARGE \kaishu{指导教师\ :\ XX}}\\[0.5cm]
    \vfill
    {\Large \today}
  \end{center}
\end{titlepage}
%-------------摘------要--------------
\newpage
\thispagestyle{empty}
\renewcommand{\abstractname}{\kaishu \sihao \textbf{摘要}}
\begin{abstract}

  \noindent  %顶格
  \textbf{\\\ 关键字：预处理器、编译器、汇编器、链接器、LLVM IR}\textbf{} \\\ \\\
\end{abstract}
%----------------------------------------------------------------
\tableofcontents
%----------------------------------------------------------------
\newpage
\watermark{60}{10}{NKU}
\setcounter{page}{1}

\section{概述}
本次实验将以编译器 clang 为研究对象，深入地探究语言处理系统的完整工作过程：
\begin{enumerate}
  \item 预处理器做了什么？
  \item 编译器做了什么？
  \item 汇编器做了什么？
  \item 链接器做了什么？
  \item 通过编写 LLVM IR 程序，熟悉 LLVM IR 中间语言。
\end{enumerate}

以一个简单的计算斐波拉契数列的 C 源程序为例，调整编译器的程序选项获得各阶段的输出，研究它们与源程序的关系。

\begin{minted}[linenos,frame=lines]{c}
#include <stdio.h>
signed main() {
  int a = 0;
  int b = 1;
  int i = 1;
  int n;
  scanf("%d%d%d", &n, &a, &b);
  while (i < n) {
    int t = b;
    b     = a + b;
    printf("%d\n", b);
    a = t;
    i = i + 1;
  }
}
\end{minted}

\section{预处理器做了什么}
预处理过程扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。可见预处理过程先于编译器对源代码进行处理。在C语言中，并没有任何内在的机制来完成如下一些功能：在编译时包含其他源文件、定义宏、根据条件决定编译时是否包含某些代码。预处理过程读入源代码，检查包含预处理指令的语句和宏定义，并对源代码进行响应的转换。预处理过程还会删除程序中的注释和多余的空白字符。预处理指令是以\#号开头的代码行。\#号必须是该行除了任何空白字符外的第一个字符。\#后是指令关键字，在关键字和\#号之间允许存在任意个数的空白字符。整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。

对于 clang 编译器，使用命令 \verb|clang fib.c -E -o fib.i|，即可得到预处理后文件。

观察预处理文件，发现文件长度远大于源文件，再对比\verb|<stdio.h>|头文件定义内容，发现多出的部分为头文件定义的具体内容和一些编译器内部记号。没有用到的头或注释则会被删去。

\section{编译器做了什么}
\subsection{词法分析}
将源程序转换为单词序列，把代码切成一个个 token，比如大小括号、等于号、还有字符串等。对于 LLVM 编译器，通过以下命令获得 token 序列：\verb|clang -E -Xclang -dump-tokens fib.c|，部分输出如图\ref{pic:1}所示。

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{figure/token.png}
  \caption{token序列}
  \label{pic:1}
\end{figure}

\subsection{语法分析}
语法分析，它的任务是验证语法是否正确，在词法分析的基础上将单词序列组合成各类此法短语，如程序、语句、表达式 等等，然后将所有节点组成抽象语法树（Abstract Syntax Tree AST），语法分析程序判断程序在结构上是否正确。

对于 gcc，可以通过\verb|-fdump-tree-original-raw| flag 获得文本格式的 AST 输出。对于 LLVM 可以通过\verb|clang -E -Xclang -ast-dump fib.c|获得相应的 AST。此处我使用后者。部分输出如图\ref{pic:2}所示，可见明确树形结构。

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{figure/AST.png}
  \caption{生成抽象语法树}
  \label{pic:2}
\end{figure}

\subsection{语义分析}
使用语法树和符号表中信息来检查源程序是否与语言定义语义一致，进行类型检查等。

\subsection{中间代码生成}
完成以上步骤后，就开始生成中间代码 LLVM IR 了，代码生成器会将语法树自顶向下遍历逐步翻译成 LLVM IR,可以通过下面命令可以生成 .ll 的文本文件，查看 IR 代码。

对于 GCC ，可以通过\verb|-fdump-tree-all-graph|和\verb|-fdump-rtl-all-graph|两个 gcc flag 获得中间代码生成的多阶段的输出。生成的 .dot 文件可以被 graphviz 可视化。

LLVM 的优化级别分别是 -O0、-O1、-O2、-O3、-Os，下面是带优化的生成中间代码 IR 的命令：\verb|clang -Os -S -fobjc-arc -emit-llvm 源文件路径 -o 输出文件路径|

LLVM 可以通过下面的命令生成 LLVM IR：\verb|clang -S -emit-llvm fib.c|
\begin{minted}[linenos,frame=lines]{NASM}
  ; ModuleID = 'fib.c'
  source_filename = "fib.c"
  target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
  target triple = "x86_64-pc-linux-gnu"
  
  @.str = private unnamed_addr constant [7 x i8] c"%d%d%d\00", align 1
  @.str.1 = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
  
  ; Function Attrs: noinline nounwind optnone sspstrong uwtable
  define dso_local i32 @main() #0 {
    %1 = alloca i32, align 4
    %2 = alloca i32, align 4
    %3 = alloca i32, align 4
    %4 = alloca i32, align 4
    %5 = alloca i32, align 4
    %6 = alloca i32, align 4
    store i32 0, i32* %1, align 4
    store i32 0, i32* %2, align 4
    store i32 1, i32* %3, align 4
    store i32 1, i32* %4, align 4
    %7 = call i32 (i8*, ...) @__isoc99_scanf(i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), i32* noundef %5, i32* noundef %2, i32* noundef %3)
    br label %8
  
  8:                                                ; preds = %12, %0
    %9 = load i32, i32* %4, align 4
    %10 = load i32, i32* %5, align 4
    %11 = icmp slt i32 %9, %10
    br i1 %11, label %12, label %22
  
  12:                                               ; preds = %8
    %13 = load i32, i32* %3, align 4
    store i32 %13, i32* %6, align 4
    %14 = load i32, i32* %2, align 4
    %15 = load i32, i32* %3, align 4
    %16 = add nsw i32 %14, %15
    store i32 %16, i32* %3, align 4
    %17 = load i32, i32* %3, align 4
    %18 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0), i32 noundef %17)
    %19 = load i32, i32* %6, align 4
    store i32 %19, i32* %2, align 4
    %20 = load i32, i32* %4, align 4
    %21 = add nsw i32 %20, 1
    store i32 %21, i32* %4, align 4
    br label %8, !llvm.loop !6
  
  22:                                               ; preds = %8
    %23 = load i32, i32* %1, align 4
    ret i32 %23
  }
  
  declare i32 @__isoc99_scanf(i8* noundef, ...) #1
  
  declare i32 @printf(i8* noundef, ...) #1
  
  attributes #0 = { noinline nounwind optnone sspstrong uwtable "frame-pointer"="all" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
  attributes #1 = { "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+cx8,+fxsr,+mmx,+sse,+sse2,+x87" "tune-cpu"="generic" }
  
  !llvm.module.flags = !{!0, !1, !2, !3, !4}
  !llvm.ident = !{!5}
  
  !0 = !{i32 1, !"wchar_size", i32 4}
  !1 = !{i32 7, !"PIC Level", i32 2}
  !2 = !{i32 7, !"PIE Level", i32 2}
  !3 = !{i32 7, !"uwtable", i32 1}
  !4 = !{i32 7, !"frame-pointer", i32 2}
  !5 = !{!"clang version 14.0.6"}
  !6 = distinct !{!6, !7}
  !7 = !{!"llvm.loop.mustprogress"}
  
\end{minted}

\subsection{代码优化}
进行与机器无关的代码优化步骤，此处通过 LLVM 现有的优化 pass 优化步骤改进中间代码，生成更好的目标代码。

pass 的分类共分为三种：Analysis Passes、Transform Passes 和 Utility Passes。Analysis Passes 用于分析或计算某些信息，以便给其他 pass 使用，如计算支配边界、控制流图的数据流分析等；Transform Passes 都会通过某种方式对中间代码形式的程序做某种变化，如死代码删除，常量传播等。

通过下面的命令生成每个 pass 后生成的 LLVM IR，以观察区别：

\verb|llc -print-before-all -print-after-all fib.ll >fib.log 2>&1|

对输出重定向到 fib.log 中，部分生成代码对比如图\ref{pic:3}所示：
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{figure/diff.png}
  \caption{左为fib.ll，右为fib.log}
  \label{pic:3}
\end{figure}

对于上述程序，反汇编后代码与先前并无明显区别。

\subsection{代码生成}
以中间表示形式作为输入，将其映射到目标语言。
此处我使用 LLVM 生成。

\begin{minted}[linenos,frame=lines]{shell}
llc fib.ll -o fib.S # LLVM 生成目标代码
\end{minted}

\begin{minted}[linenos,frame=lines]{ASM}
  .text
  .file  "fib.c"
  .globl  main                            # -- Begin function main
  .p2align  4, 0x90
  .type  main,@function
main:                                   # @main
  .cfi_startproc
# %bb.0:
  pushq  %rbp
  .cfi_def_cfa_offset 16
  .cfi_offset %rbp, -16
  movq  %rsp, %rbp
  .cfi_def_cfa_register %rbp
  subq  $32, %rsp
  movq  %fs:40, %rax
  movq  %rax, -8(%rbp)
  movl  $0, -32(%rbp)
  movl  $0, -12(%rbp)
  movl  $1, -16(%rbp)
  movl  $1, -24(%rbp)
  movabsq  $.L.str, %rdi
  leaq  -20(%rbp), %rsi
  leaq  -12(%rbp), %rdx
  leaq  -16(%rbp), %rcx
  movb  $0, %al
  callq  __isoc99_scanf@PLT
.LBB0_1:                                # =>This Inner Loop Header: Depth=1
  movl  -24(%rbp), %eax
  cmpl  -20(%rbp), %eax
  jge  .LBB0_3
# %bb.2:                                #   in Loop: Header=BB0_1 Depth=1
  movl  -16(%rbp), %eax
  movl  %eax, -28(%rbp)
  movl  -12(%rbp), %eax
  addl  -16(%rbp), %eax
  movl  %eax, -16(%rbp)
  movl  -16(%rbp), %esi
  movabsq  $.L.str.1, %rdi
  movb  $0, %al
  callq  printf@PLT
  movl  -28(%rbp), %eax
  movl  %eax, -12(%rbp)
  movl  -24(%rbp), %eax
  addl  $1, %eax
  movl  %eax, -24(%rbp)
  jmp  .LBB0_1
.LBB0_3:
  movl  -32(%rbp), %eax
  movq  %fs:40, %rcx
  movq  -8(%rbp), %rdx
  cmpq  %rdx, %rcx
  jne  .LBB0_5
# %bb.4:                                # %SP_return
  addq  $32, %rsp
  popq  %rbp
  .cfi_def_cfa %rsp, 8
  retq
.LBB0_5:                                # %CallStackCheckFailBlk
  .cfi_def_cfa %rbp, 16
  callq  __stack_chk_fail@PLT
.Lfunc_end0:
  .size  main, .Lfunc_end0-main
  .cfi_endproc
                                        # -- End function
  .type  .L.str,@object                  # @.str
  .section  .rodata.str1.1,"aMS",@progbits,1
.L.str:
  .asciz  "%d%d%d"
  .size  .L.str, 7

  .type  .L.str.1,@object                # @.str.1
.L.str.1:
  .asciz  "%d\n"
  .size  .L.str.1, 4

  .ident  "clang version 14.0.6"
  .section  ".note.GNU-stack","",@progbits

\end{minted}

\section{汇编器做了什么}
汇编过程实际上把汇编语言程序代码翻译成目标机器指令的过程。其最终生成的是可重定位的机器代码。这一步一般被视为编译过程的“后端”。

LLVM 在后端主要是会通过一个个的 Pass 去优化，每个 Pass 做一些事情，最终生成汇编代码。我们通过最终的 .bc 或者 .ll 代码生成汇编代码:
\begin{minted}[linenos,frame=lines]{shell}
clang -S -fobjc-arc fib.bc -o fib.s
clang -S -fobjc-arc fib.ll -o fib.s
\end{minted}

生成代码也可以进行优化：\verb|clang -Os -S -fobjc-arc fib.m -o fib.s|

同时也可以直接使用 llc 命令同时汇编和链接 LLVM bitcode：

\verb|llc fib.bc -filetype=obj -o fib.o|

上面的指令需要用到 bc 格式，即 LLVM IR 的二进制代码形式，而之前生成的是 LLVM IR 的文本形式。

可以通过下面的命令让 bc 和 ll 这两种 LLVM IR 格式互转，以统一文件格式：

\begin{minted}[linenos,frame=lines]{shell}
llvm-dis a.bc -o a.ll # bc 转换为 ll
llvm-as a.ll -o a.bc # ll 转换为 bc
\end{minted}

使用 llc 命令同时汇编和链接 LLVM bitcode，可以得到 fib.o 二进制文件。

llc指令用于将LLVM源输入编译成特定架构的汇编语言，然后汇编语言输出可以通过本机汇编器和链接器来生成本机可执行文件。汇编器具体功能则是把汇编语言源文件翻译成机器语言目标文件,机器语言格式为公用目标格式。链接器用于把多个目标文件组合成单个可执行目标模块。它一边创建可执行模块，一边完成重定位以及决定外部参考。链接器的输入是可重定位的目标文件和目标库文件

对于生成的 fib.o 文件，使用如下命令

\begin{minted}[linenos,frame=lines]{shell}
objdump -d fib.o >fib-anti-obj.S
\end{minted}

对机器码进行反汇编得到 fib-anti-obj.S 文件，得到的反汇编结果如下：

\begin{minted}[linenos,frame=lines]{ASM}

  fib.o：     文件格式 elf64-x86-64


  Disassembly of section .text:
  
  0000000000000000 <main>:
     0:  55                     push   %rbp
     1:  48 89 e5               mov    %rsp,%rbp
     4:  48 83 ec 20            sub    $0x20,%rsp
     8:  64 48 8b 04 25 28 00   mov    %fs:0x28,%rax
     f:  00 00 
    11:  48 89 45 f8            mov    %rax,-0x8(%rbp)
    15:  c7 45 e0 00 00 00 00   movl   $0x0,-0x20(%rbp)
    1c:  c7 45 f4 00 00 00 00   movl   $0x0,-0xc(%rbp)
    23:  c7 45 f0 01 00 00 00   movl   $0x1,-0x10(%rbp)
    2a:  c7 45 e8 01 00 00 00   movl   $0x1,-0x18(%rbp)
    31:  48 bf 00 00 00 00 00   movabs $0x0,%rdi
    38:  00 00 00 
    3b:  48 8d 75 ec            lea    -0x14(%rbp),%rsi
    3f:  48 8d 55 f4            lea    -0xc(%rbp),%rdx
    43:  48 8d 4d f0            lea    -0x10(%rbp),%rcx
    47:  b0 00                  mov    $0x0,%al
    49:  e8 00 00 00 00         call   4e <main+0x4e>
    4e:  8b 45 e8               mov    -0x18(%rbp),%eax
    51:  3b 45 ec               cmp    -0x14(%rbp),%eax
    54:  7d 34                  jge    8a <main+0x8a>
    56:  8b 45 f0               mov    -0x10(%rbp),%eax
    59:  89 45 e4               mov    %eax,-0x1c(%rbp)
    5c:  8b 45 f4               mov    -0xc(%rbp),%eax
    5f:  03 45 f0               add    -0x10(%rbp),%eax
    62:  89 45 f0               mov    %eax,-0x10(%rbp)
    65:  8b 75 f0               mov    -0x10(%rbp),%esi
    68:  48 bf 00 00 00 00 00   movabs $0x0,%rdi
    6f:  00 00 00 
    72:  b0 00                  mov    $0x0,%al
    74:  e8 00 00 00 00         call   79 <main+0x79>
    79:  8b 45 e4               mov    -0x1c(%rbp),%eax
    7c:  89 45 f4               mov    %eax,-0xc(%rbp)
    7f:  8b 45 e8               mov    -0x18(%rbp),%eax
    82:  83 c0 01               add    $0x1,%eax
    85:  89 45 e8               mov    %eax,-0x18(%rbp)
    88:  eb c4                  jmp    4e <main+0x4e>
    8a:  8b 45 e0               mov    -0x20(%rbp),%eax
    8d:  64 48 8b 0c 25 28 00   mov    %fs:0x28,%rcx
    94:  00 00 
    96:  48 8b 55 f8            mov    -0x8(%rbp),%rdx
    9a:  48 39 d1               cmp    %rdx,%rcx
    9d:  75 06                  jne    a5 <main+0xa5>
    9f:  48 83 c4 20            add    $0x20,%rsp
    a3:  5d                     pop    %rbp
    a4:  c3                     ret
    a5:  e8 00 00 00 00         call   aa <main+0xaa>
  
\end{minted}

对比原汇编代码 fib.S 文件可见，主体部分的代码完全一致，原文件中 label、无用的标记符号等被删去，得到了更为简单的汇编代码。

\section{链接器做了什么}
由汇编程序生成的目标文件不能够直接执行。大型程序经常被分成多个部分进行编译，因此，可重定位的机器代码有必要和其他可重定位的目标文件以及库文件链接到一起，最终形成真正在机器上运行的代码。进而链接器对该机器代码进行执行生成可执行文件。
\verb|clang fib.o -o fib|

对可执行文件进行反汇编：\verb|objdump -d fib >fib-anti-exe.S|，得到的反汇编结果如下：

\begin{minted}[linenos,frame=lines]{ASM}

  fib：     文件格式 elf64-x86-64


  Disassembly of section .init:
  
  0000000000001000 <_init>:
      1000:  f3 0f 1e fa            endbr64
      1004:  48 83 ec 08            sub    $0x8,%rsp
      1008:  48 8b 05 c1 2f 00 00   mov    0x2fc1(%rip),%rax        # 3fd0 <__gmon_start__@Base>
      100f:  48 85 c0               test   %rax,%rax
      1012:  74 02                  je     1016 <_init+0x16>
      1014:  ff d0                  call   *%rax
      1016:  48 83 c4 08            add    $0x8,%rsp
      101a:  c3                     ret
  
  Disassembly of section .plt:
  
  0000000000001020 <__stack_chk_fail@plt-0x10>:
      1020:  ff 35 ca 2f 00 00      push   0x2fca(%rip)        # 3ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
      1026:  ff 25 cc 2f 00 00      jmp    *0x2fcc(%rip)        # 3ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
      102c:  0f 1f 40 00            nopl   0x0(%rax)
  
  0000000000001030 <__stack_chk_fail@plt>:
      1030:  ff 25 ca 2f 00 00      jmp    *0x2fca(%rip)        # 4000 <__stack_chk_fail@GLIBC_2.4>
      1036:  68 00 00 00 00         push   $0x0
      103b:  e9 e0 ff ff ff         jmp    1020 <_init+0x20>
  
  0000000000001040 <printf@plt>:
      1040:  ff 25 c2 2f 00 00      jmp    *0x2fc2(%rip)        # 4008 <printf@GLIBC_2.2.5>
      1046:  68 01 00 00 00         push   $0x1
      104b:  e9 d0 ff ff ff         jmp    1020 <_init+0x20>
  
  0000000000001050 <__isoc99_scanf@plt>:
      1050:  ff 25 ba 2f 00 00      jmp    *0x2fba(%rip)        # 4010 <__isoc99_scanf@GLIBC_2.7>
      1056:  68 02 00 00 00         push   $0x2
      105b:  e9 c0 ff ff ff         jmp    1020 <_init+0x20>
  
  Disassembly of section .text:
  
  0000000000001060 <_start>:
      1060:  f3 0f 1e fa            endbr64
      1064:  31 ed                  xor    %ebp,%ebp
      1066:  49 89 d1               mov    %rdx,%r9
      1069:  5e                     pop    %rsi
      106a:  48 89 e2               mov    %rsp,%rdx
      106d:  48 83 e4 f0            and    $0xfffffffffffffff0,%rsp
      1071:  50                     push   %rax
      1072:  54                     push   %rsp
      1073:  45 31 c0               xor    %r8d,%r8d
      1076:  31 c9                  xor    %ecx,%ecx
      1078:  48 8d 3d e1 00 00 00   lea    0xe1(%rip),%rdi        # 1160 <main>
      107f:  ff 15 3b 2f 00 00      call   *0x2f3b(%rip)        # 3fc0 <__libc_start_main@GLIBC_2.34>
      1085:  f4                     hlt
      1086:  66 2e 0f 1f 84 00 00   cs nopw 0x0(%rax,%rax,1)
      108d:  00 00 00 
  
  0000000000001090 <deregister_tm_clones>:
      1090:  48 8d 3d 91 2f 00 00   lea    0x2f91(%rip),%rdi        # 4028 <__TMC_END__>
      1097:  48 8d 05 8a 2f 00 00   lea    0x2f8a(%rip),%rax        # 4028 <__TMC_END__>
      109e:  48 39 f8               cmp    %rdi,%rax
      10a1:  74 15                  je     10b8 <deregister_tm_clones+0x28>
      10a3:  48 8b 05 1e 2f 00 00   mov    0x2f1e(%rip),%rax        # 3fc8 <_ITM_deregisterTMCloneTable@Base>
      10aa:  48 85 c0               test   %rax,%rax
      10ad:  74 09                  je     10b8 <deregister_tm_clones+0x28>
      10af:  ff e0                  jmp    *%rax
      10b1:  0f 1f 80 00 00 00 00   nopl   0x0(%rax)
      10b8:  c3                     ret
      10b9:  0f 1f 80 00 00 00 00   nopl   0x0(%rax)
  
  00000000000010c0 <register_tm_clones>:
      10c0:  48 8d 3d 61 2f 00 00   lea    0x2f61(%rip),%rdi        # 4028 <__TMC_END__>
      10c7:  48 8d 35 5a 2f 00 00   lea    0x2f5a(%rip),%rsi        # 4028 <__TMC_END__>
      10ce:  48 29 fe               sub    %rdi,%rsi
      10d1:  48 89 f0               mov    %rsi,%rax
      10d4:  48 c1 ee 3f            shr    $0x3f,%rsi
      10d8:  48 c1 f8 03            sar    $0x3,%rax
      10dc:  48 01 c6               add    %rax,%rsi
      10df:  48 d1 fe               sar    %rsi
      10e2:  74 14                  je     10f8 <register_tm_clones+0x38>
      10e4:  48 8b 05 ed 2e 00 00   mov    0x2eed(%rip),%rax        # 3fd8 <_ITM_registerTMCloneTable@Base>
      10eb:  48 85 c0               test   %rax,%rax
      10ee:  74 08                  je     10f8 <register_tm_clones+0x38>
      10f0:  ff e0                  jmp    *%rax
      10f2:  66 0f 1f 44 00 00      nopw   0x0(%rax,%rax,1)
      10f8:  c3                     ret
      10f9:  0f 1f 80 00 00 00 00   nopl   0x0(%rax)
  
  0000000000001100 <__do_global_dtors_aux>:
      1100:  f3 0f 1e fa            endbr64
      1104:  80 3d 1d 2f 00 00 00   cmpb   $0x0,0x2f1d(%rip)        # 4028 <__TMC_END__>
      110b:  75 33                  jne    1140 <__do_global_dtors_aux+0x40>
      110d:  55                     push   %rbp
      110e:  48 83 3d ca 2e 00 00   cmpq   $0x0,0x2eca(%rip)        # 3fe0 <__cxa_finalize@GLIBC_2.2.5>
      1115:  00 
      1116:  48 89 e5               mov    %rsp,%rbp
      1119:  74 0d                  je     1128 <__do_global_dtors_aux+0x28>
      111b:  48 8b 3d fe 2e 00 00   mov    0x2efe(%rip),%rdi        # 4020 <__dso_handle>
      1122:  ff 15 b8 2e 00 00      call   *0x2eb8(%rip)        # 3fe0 <__cxa_finalize@GLIBC_2.2.5>
      1128:  e8 63 ff ff ff         call   1090 <deregister_tm_clones>
      112d:  c6 05 f4 2e 00 00 01   movb   $0x1,0x2ef4(%rip)        # 4028 <__TMC_END__>
      1134:  5d                     pop    %rbp
      1135:  c3                     ret
      1136:  66 2e 0f 1f 84 00 00   cs nopw 0x0(%rax,%rax,1)
      113d:  00 00 00 
      1140:  c3                     ret
      1141:  66 66 2e 0f 1f 84 00   data16 cs nopw 0x0(%rax,%rax,1)
      1148:  00 00 00 00 
      114c:  0f 1f 40 00            nopl   0x0(%rax)
  
  0000000000001150 <frame_dummy>:
      1150:  f3 0f 1e fa            endbr64
      1154:  e9 67 ff ff ff         jmp    10c0 <register_tm_clones>
      1159:  0f 1f 80 00 00 00 00   nopl   0x0(%rax)
  
  0000000000001160 <main>:
      1160:  55                     push   %rbp
      1161:  48 89 e5               mov    %rsp,%rbp
      1164:  48 83 ec 20            sub    $0x20,%rsp
      1168:  64 48 8b 04 25 28 00   mov    %fs:0x28,%rax
      116f:  00 00 
      1171:  48 89 45 f8            mov    %rax,-0x8(%rbp)
      1175:  c7 45 e0 00 00 00 00   movl   $0x0,-0x20(%rbp)
      117c:  c7 45 f4 00 00 00 00   movl   $0x0,-0xc(%rbp)
      1183:  c7 45 f0 01 00 00 00   movl   $0x1,-0x10(%rbp)
      118a:  c7 45 e8 01 00 00 00   movl   $0x1,-0x18(%rbp)
      1191:  48 bf 04 20 00 00 00   movabs $0x2004,%rdi
      1198:  00 00 00 
      119b:  48 8d 75 ec            lea    -0x14(%rbp),%rsi
      119f:  48 8d 55 f4            lea    -0xc(%rbp),%rdx
      11a3:  48 8d 4d f0            lea    -0x10(%rbp),%rcx
      11a7:  b0 00                  mov    $0x0,%al
      11a9:  e8 a2 fe ff ff         call   1050 <__isoc99_scanf@plt>
      11ae:  8b 45 e8               mov    -0x18(%rbp),%eax
      11b1:  3b 45 ec               cmp    -0x14(%rbp),%eax
      11b4:  7d 34                  jge    11ea <main+0x8a>
      11b6:  8b 45 f0               mov    -0x10(%rbp),%eax
      11b9:  89 45 e4               mov    %eax,-0x1c(%rbp)
      11bc:  8b 45 f4               mov    -0xc(%rbp),%eax
      11bf:  03 45 f0               add    -0x10(%rbp),%eax
      11c2:  89 45 f0               mov    %eax,-0x10(%rbp)
      11c5:  8b 75 f0               mov    -0x10(%rbp),%esi
      11c8:  48 bf 0b 20 00 00 00   movabs $0x200b,%rdi
      11cf:  00 00 00 
      11d2:  b0 00                  mov    $0x0,%al
      11d4:  e8 67 fe ff ff         call   1040 <printf@plt>
      11d9:  8b 45 e4               mov    -0x1c(%rbp),%eax
      11dc:  89 45 f4               mov    %eax,-0xc(%rbp)
      11df:  8b 45 e8               mov    -0x18(%rbp),%eax
      11e2:  83 c0 01               add    $0x1,%eax
      11e5:  89 45 e8               mov    %eax,-0x18(%rbp)
      11e8:  eb c4                  jmp    11ae <main+0x4e>
      11ea:  8b 45 e0               mov    -0x20(%rbp),%eax
      11ed:  64 48 8b 0c 25 28 00   mov    %fs:0x28,%rcx
      11f4:  00 00 
      11f6:  48 8b 55 f8            mov    -0x8(%rbp),%rdx
      11fa:  48 39 d1               cmp    %rdx,%rcx
      11fd:  75 06                  jne    1205 <main+0xa5>
      11ff:  48 83 c4 20            add    $0x20,%rsp
      1203:  5d                     pop    %rbp
      1204:  c3                     ret
      1205:  e8 26 fe ff ff         call   1030 <__stack_chk_fail@plt>
  
  Disassembly of section .fini:
  
  000000000000120c <_fini>:
      120c:  f3 0f 1e fa            endbr64
      1210:  48 83 ec 08            sub    $0x8,%rsp
      1214:  48 83 c4 08            add    $0x8,%rsp
      1218:  c3                     ret
  
\end{minted}

可以发现所得结果长度大大增加，相较上一层新增了链接所得的内容。

\section{LLVM IR编程}
本次SysY语言特性研究，涵盖了函数，语句块，变量定义特性的程序例子编写和验证。

\subsection{变量定义}
此处定义了一个 int 类型变量、一个 int 类型指针、 一个 float 类型变量，并分别定义时赋值、赋值地址、定义后赋值。

\begin{minted}[linenos,frame=lines]{NASM}
@.str = private unnamed_addr constant [7 x i8] c"%d%p%f\00", align 1

define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32*, align 8
  %3 = alloca float, align 4
  store i32 1, i32* %1, align 4
  store i32* %1, i32** %2, align 8
  store float 2.500000e+00, float* %3, align 4
  %4 = load i32, i32* %1, align 4
  %5 = load i32*, i32** %2, align 8
  %6 = load float, float* %3, align 4
  %7 = fpext float %6 to double
  %8 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), i32 noundef %4, i32* noundef %5, double noundef %7)
  ret i32 0
}

declare i32 @printf(i8* noundef, ...) #1

\end{minted}

经过格式转换、汇编、链接，运行可执行程序可得正确输出结果如图\ref{pic:4}：
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{figure/exa.png}
  \caption{变量定义输出结果}
  \label{pic:4}
\end{figure}

\subsection{语句块}
此处设计了一个普通语句块对变量进行修改和查看，并且设置了一个条件分支语句块和一个循环分支语句块。

\begin{minted}[linenos,frame=lines]{NASM}

@.str = private unnamed_addr constant [3 x i8] c"%d\00", align 1

define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  store i32 0, i32* %1, align 4
  store i32 1, i32* %3, align 4
  %7 = call i32 (i8*, ...) @__isoc99_scanf(i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32* noundef %2)
  store i32 0, i32* %5, align 4
  %8 = load i32, i32* %5, align 4
  %9 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 noundef %8)
  %10 = load i32, i32* %3, align 4
  %11 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 noundef %10)
  %12 = load i32, i32* %2, align 4
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %14, label %27

  14:                                               ; preds = %0
  store i32 0, i32* %4, align 4
  store i32 1, i32* %6, align 4
  br label %15

  15:                                               ; preds = %23, %14
  %16 = load i32, i32* %6, align 4
  %17 = load i32, i32* %2, align 4
  %18 = icmp sle i32 %16, %17
  br i1 %18, label %19, label %26

  19:                                               ; preds = %15
  %20 = load i32, i32* %3, align 4
  %21 = load i32, i32* %4, align 4
  %22 = add nsw i32 %20, %21
  store i32 %22, i32* %4, align 4
  br label %23

  23:                                               ; preds = %19
  %24 = load i32, i32* %6, align 4
  %25 = add nsw i32 %24, 1
  store i32 %25, i32* %6, align 4
  br label %15, !llvm.loop !6

  26:                                               ; preds = %15
  br label %27

  27:                                               ; preds = %26, %0
  %28 = load i32, i32* %1, align 4
  ret i32 %28
}

declare i32 @__isoc99_scanf(i8* noundef, ...) #1

declare i32 @printf(i8* noundef, ...) #1

\end{minted}

经过格式转换、汇编、链接，运行可执行程序可得正确输出结果如图\ref{pic:5}：
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{figure/exb.png}
  \caption{语句块输出结果}
  \label{pic:5}
\end{figure}

\subsection{函数}
这里设置了三个函数，一个返回 int 类型且不含参数，一个空类型且不含参数，一个返回 float 类型且含一个 int 类型参数。分别验证返回结果。
\begin{minted}[linenos,frame=lines]{NASM}

@b = dso_local global i32 0, align 4
@.str = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"%f\0A\00", align 1

define dso_local i32 @f1() #0 {
  %1 = load i32, i32* @b, align 4
  ret i32 %1
}

define dso_local void @f2() #0 {
  store i32 1, i32* @b, align 4
  ret void
}

define dso_local float @f3(i32 noundef %0) #0 {
%2 = alloca i32, align 4
store i32 %0, i32* %2, align 4
%3 = load i32, i32* %2, align 4
%4 = sdiv i32 %3, 2
%5 = sitofp i32 %4 to float
ret float %5
}

define dso_local i32 @main() #0 {
  store i32 0, i32* @b, align 4
  %1 = call i32 @f1()
  %2 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %1)
  call void @f2()
  %3 = load i32, i32* @b, align 4
  %4 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str, i64 0, i64 0), i32 noundef %3)
  %5 = load i32, i32* @b, align 4
  %6 = call float @f3(i32 noundef %5)
  %7 = fpext float %6 to double
  %8 = call i32 (i8*, ...) @printf(i8* noundef getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i64 0, i64 0), double noundef %7)
  ret i32 0
}

declare i32 @printf(i8* noundef, ...) #1

\end{minted}

经过格式转换、汇编、链接，运行可执行程序可得正确输出结果如图\ref{pic:6}：
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{figure/exc.png}
  \caption{函数输出结果}
  \label{pic:6}
\end{figure}

\subsection{数组定义}

这里设计了不同维度，int和float类型的数组定义。

\begin{minted}[linenos,frame=lines]{NASM}
define dso_local i32 @main() #0 {
  %1 = alloca [2 x i32], align 4
  %2 = alloca [3 x [5 x i32]], align 16
  %3 = alloca [7 x [11 x [2 x i32]]], align 16
  %4 = alloca [13 x float], align 16
  %5 = alloca [2 x [4 x [6 x [10 x float]]]], align 16
  ret i32 0
}
\end{minted}

\subsection{隐式转换}

这里设计了int to float 和 float to int 两种隐式类型转换，等价SysY代码如下

\begin{minted}[linenos,frame=lines]{c}
int   i1 = 3.141592654;
int   i2 = 0.499999;
int   i3 = 0.500000;
int   i4 = 0.500001;
int   i5 = -0.499999;
int   i6 = -0.500000;
int   i7 = -0.500001;
float f1 = 3141592654;
float f2 = -314;
int   i8 = f1 / f2;
float f3 = i1 + i8;
\end{minted}

隐式转换中，字面常量会直接被编译器计算，float to int过程中会被截断小数部分，因此上述代码i2~i7均为0。int to float过程中按照IEEE 754规范转换，如果数字过大或过小会转换成inf。如果是没有在编译期确定的常量，会使用fptosi指令将浮点数转换成整数、sitofp指令将整数转换成浮点数。

\begin{minted}[linenos,frame=lines]{NASM}
define dso_local i32 @main() #0 {
  %1 = alloca i32, align 4
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  %4 = alloca i32, align 4
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca float, align 4
  %9 = alloca float, align 4
  %10 = alloca i32, align 4
  %11 = alloca float, align 4
  store i32 3, i32* %1, align 4
  store i32 0, i32* %2, align 4
  store i32 0, i32* %3, align 4
  store i32 0, i32* %4, align 4
  store i32 0, i32* %5, align 4
  store i32 0, i32* %6, align 4
  store i32 0, i32* %7, align 4
  store float 0x41E7681CC0000000, float* %8, align 4
  store float -3.140000e+02, float* %9, align 4
  %12 = load float, float* %8, align 4
  %13 = load float, float* %9, align 4
  %14 = fdiv float %12, %13
  %15 = fptosi float %14 to i32
  store i32 %15, i32* %10, align 4
  %16 = load i32, i32* %1, align 4
  %17 = load i32, i32* %10, align 4
  %18 = add nsw i32 %16, %17
  %19 = sitofp i32 %18 to float
  store float %19, float* %11, align 4
  ret i32 0
}
\end{minted}

\section{总结}
通过实战编写LLVM/IR程序，更深入地感受了语言处理系统各项完整的工作过程，熟悉了 LLVM IR 中间语言，并对其实现方式有了一定了解，为今后编写完整编译器打下良好基础。

\end{document}